#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import postgres from "postgres";

function loadDotEnv() {
  const envPath = path.resolve(process.cwd(), ".env");
  if (!fs.existsSync(envPath)) return;

  const content = fs.readFileSync(envPath, "utf8");
  for (const rawLine of content.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) continue;

    const separatorIndex = line.indexOf("=");
    if (separatorIndex <= 0) continue;

    const key = line.slice(0, separatorIndex).trim();
    if (!key || process.env[key] !== undefined) continue;

    let value = line.slice(separatorIndex + 1).trim();
    if (
      (value.startsWith("\"") && value.endsWith("\"")) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    process.env[key] = value;
  }
}

loadDotEnv();

const SOURCE_URL = process.env.NEON_DATABASE_URL || process.env.DATABASE_URL;
if (!SOURCE_URL) {
  console.error("Missing NEON_DATABASE_URL (or DATABASE_URL) for source Neon database.");
  process.exit(1);
}

const outputPath = process.argv[2] || "./tmp/neon-data.sql";

const tables = [
  "users",
  "identities",
  "passkeys",
  "devices",
  "sessions",
  "login_requests",
  "trust_codes",
  "activity_logs",
  "oauth_apps",
  "oauth_authorizations",
  "oauth_refresh_tokens",
  "signing_keys",
  "signature_requests",
];

const deleteOrder = [...tables].reverse();

const timestampColumns = new Set([
  "created_at",
  "updated_at",
  "last_used_at",
  "last_seen_at",
  "expires_at",
  "used_at",
  "revoked_at",
  "reuse_detected_at",
  "resolved_at",
]);

const booleanColumns = new Set([
  "is_primary",
  "backed_up",
  "is_active",
  "allow_user_id_scope",
  "supports_e2ee",
]);

const jsonColumnsByTable = {
  users: new Set(["security_questions"]),
  passkeys: new Set(["transports"]),
  devices: new Set(["push_subscription"]),
  activity_logs: new Set(["details"]),
  oauth_apps: new Set(["redirect_uris", "allowed_scopes"]),
  signature_requests: new Set(["metadata"]),
};

function escapeSqlString(value) {
  return value.replace(/'/g, "''");
}

function toEpochMs(value) {
  if (value == null) return null;
  if (value instanceof Date) return value.getTime();
  if (typeof value === "number") return Number.isFinite(value) ? Math.trunc(value) : null;
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function normalizeBoolean(value) {
  if (value == null) return null;
  if (typeof value === "boolean") return value ? 1 : 0;
  if (typeof value === "number") return value ? 1 : 0;
  if (typeof value === "string") {
    const normalized = value.toLowerCase();
    if (normalized === "true" || normalized === "t" || normalized === "1") return 1;
    if (normalized === "false" || normalized === "f" || normalized === "0") return 0;
  }
  return null;
}

function serializeValue({ table, column, value }) {
  if (value == null) return "NULL";

  if (timestampColumns.has(column)) {
    const ms = toEpochMs(value);
    return ms == null ? "NULL" : String(ms);
  }

  if (booleanColumns.has(column)) {
    const b = normalizeBoolean(value);
    return b == null ? "NULL" : String(b);
  }

  if (jsonColumnsByTable[table]?.has(column)) {
    const json = typeof value === "string" ? value : JSON.stringify(value);
    return `'${escapeSqlString(json)}'`;
  }

  if (typeof value === "number") return Number.isFinite(value) ? String(value) : "NULL";
  if (typeof value === "bigint") return String(value);
  if (typeof value === "boolean") return value ? "1" : "0";
  if (value instanceof Date) return String(value.getTime());

  if (value instanceof Uint8Array) {
    return `'${escapeSqlString(Buffer.from(value).toString("base64"))}'`;
  }

  return `'${escapeSqlString(String(value))}'`;
}

function quoteIdentifier(identifier) {
  return `\`${identifier.replace(/`/g, "``")}\``;
}

async function run() {
  const sql = postgres(SOURCE_URL, {
    max: 1,
    prepare: false,
    idle_timeout: 5,
    connect_timeout: 30,
  });

  try {
    const lines = [];
    lines.push("-- Generated by scripts/export-neon-to-d1.mjs");
    lines.push(`-- Source export timestamp: ${new Date().toISOString()}`);

    for (const table of deleteOrder) {
      lines.push(`DELETE FROM ${quoteIdentifier(table)};`);
    }

    for (const table of tables) {
      const rows = await sql.unsafe(`SELECT * FROM \"${table}\";`);
      console.log(`Exporting ${table}: ${rows.length} rows`);

      for (const row of rows) {
        const columns = Object.keys(row);
        if (columns.length === 0) continue;

        const columnSql = columns.map((c) => quoteIdentifier(c)).join(", ");
        const valuesSql = columns
          .map((column) =>
            serializeValue({
              table,
              column,
              value: row[column],
            })
          )
          .join(", ");

        lines.push(
          `INSERT INTO ${quoteIdentifier(table)} (${columnSql}) VALUES (${valuesSql});`
        );
      }
    }

    const resolvedOutputPath = path.resolve(process.cwd(), outputPath);
    fs.mkdirSync(path.dirname(resolvedOutputPath), { recursive: true });
    fs.writeFileSync(resolvedOutputPath, `${lines.join("\n")}\n`, "utf8");

    console.log(`Wrote D1 import SQL to ${resolvedOutputPath}`);
  } finally {
    await sql.end({ timeout: 5 });
  }
}

run().catch((error) => {
  console.error("Failed to export Neon data:", error);
  process.exit(1);
});
